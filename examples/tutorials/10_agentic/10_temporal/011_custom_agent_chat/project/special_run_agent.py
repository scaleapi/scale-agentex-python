import json
from typing import Any, List, TypedDict, AsyncGenerator
from contextlib import AsyncExitStack, asynccontextmanager
from dataclasses import dataclass

from mcp import StdioServerParameters
from agents import Agent, Runner, TResponseInputItem
from pydantic import BaseModel, TypeAdapter
from agents.mcp import MCPServer, MCPServerStdio, MCPServerStdioParams
from temporalio import activity
from openai.types.responses import ResponseFunctionToolCall

from agentex.lib import adk
from agentex.lib.utils.mcp import redact_mcp_server_params
from agentex.types.task_message_content import TextContent  # type: ignore[attr-defined]
from agentex.types.tool_request_content import ToolRequestContent
from agentex.types.tool_response_content import ToolResponseContent
from agentex.lib.types.task_message_updates import TextDelta, StreamTaskMessageFull, StreamTaskMessageDelta
from agentex.lib.core.services.adk.streaming import StreamingTaskMessageContext


@asynccontextmanager
async def _dummy_async_generator_context_manager() -> AsyncGenerator[None, None]:
    yield None
    return


@asynccontextmanager
async def _mcp_server_context(
    params_list: list[MCPServerStdioParams],
    timeout_seconds: int | None = None,
) -> AsyncGenerator[list[MCPServer], None]:
    """Context manager for MCP servers."""
    servers: list[MCPServerStdio] = []
    for params in params_list:
        servers.append(
            MCPServerStdio(
                name=f"Server: {params['command']}",
                params=params,
                cache_tools_list=True,
                client_session_timeout_seconds=timeout_seconds,
            )
        )

    async with AsyncExitStack() as stack:
        for server in servers:
            await stack.enter_async_context(server)
        abc_servers: list[MCPServer] = [server for server in servers]
        yield abc_servers


SPECIAL_RUN_AGENT_ACTIVITY_NAME = "special_run_agent"


@dataclass
class SpecialRunAgentParams:
    task_id: str
    input_list: list[TResponseInputItem]
    mcp_server_params: list[MCPServerStdioParams]
    agent_name: str
    agent_instructions: str
    trace_id: str | None = None
    parent_span_id: str | None = None
    mcp_timeout_seconds: int | None = None
    model: str | None = None


class SpecialRunAgentResult(TypedDict):
    final_output: Any
    """The final output of the agent. This should not be None."""

    final_input_list: list[TResponseInputItem]
    """The original input, plus all the new input items generated by the agent."""


@activity.defn(name=SPECIAL_RUN_AGENT_ACTIVITY_NAME)
async def special_run_agent(params: SpecialRunAgentParams) -> SpecialRunAgentResult:
    """Run an agent with streaming and automatic TaskMessage creation."""

    tool_call_map: dict[str, ResponseFunctionToolCall] = {}
    redacted_params = redact_mcp_server_params(
        TypeAdapter(List[StdioServerParameters]).validate_python(params.mcp_server_params)
    )

    async with (
        adk.tracing.span(
            trace_id=params.trace_id,
            name=SPECIAL_RUN_AGENT_ACTIVITY_NAME,
            parent_id=params.parent_span_id,
            input={
                "task_id": params.task_id,
                "input_list": params.input_list,
                "mcp_server_params": redacted_params,
                "agent_name": params.agent_name,
                "agent_instructions": params.agent_instructions,
                "model": params.model,
            },
        )
        if params.trace_id
        else _dummy_async_generator_context_manager()
    ) as span:
        activity.heartbeat("special run agent")

        async with _mcp_server_context(params.mcp_server_params, timeout_seconds=params.mcp_timeout_seconds) as servers:
            agent = Agent(
                name=params.agent_name,
                instructions=params.agent_instructions,
                mcp_servers=servers,
                model=params.model,
            )

            # Run with streaming
            result = Runner.run_streamed(starting_agent=agent, input=params.input_list)

            item_id_to_streaming_context: dict[str, StreamingTaskMessageContext] = {}
            unclosed_item_ids: set[str] = set()

            try:
                # Process streaming events with TaskMessage creation
                async for event in result.stream_events():
                    activity.heartbeat("processing stream event with auto send")

                    if event.type == "run_item_stream_event":
                        if event.item.type == "tool_call_item" and event.item.raw_item.type == "function_call":
                            tool_call_item = event.item.raw_item
                            tool_call_map[tool_call_item.call_id] = tool_call_item

                            tool_request_content = ToolRequestContent(
                                arguments=json.loads(tool_call_item.arguments),
                                author="agent",
                                name=tool_call_item.name,
                                tool_call_id=tool_call_item.call_id,
                            )

                            # Create tool request using streaming context (immediate completion)
                            async with adk.streaming.streaming_task_message_context(
                                task_id=params.task_id,
                                initial_content=tool_request_content,
                            ) as streaming_context:
                                # The message has already been persisted, but we still need to send an update
                                await streaming_context.stream_update(
                                    update=StreamTaskMessageFull(
                                        parent_task_message=streaming_context.task_message,
                                        content=tool_request_content,
                                    ),
                                )

                        elif (
                            event.item.type == "tool_call_output_item"
                            and event.item.raw_item["type"] == "function_call_output"
                        ):
                            tool_output_item = event.item.raw_item

                            tool_response_content = ToolResponseContent(
                                author="agent",
                                tool_call_id=tool_output_item["call_id"],
                                name=tool_call_map[tool_output_item["call_id"]].name,
                                content=tool_output_item["output"],
                            )

                            # Create tool response using streaming context (immediate completion)
                            async with adk.streaming.streaming_task_message_context(
                                task_id=params.task_id,
                                initial_content=tool_response_content,
                            ) as streaming_context:
                                # The message has already been persisted, but we still need to send an update
                                await streaming_context.stream_update(
                                    update=StreamTaskMessageFull(
                                        parent_task_message=streaming_context.task_message,
                                        content=tool_response_content,
                                    ),
                                )

                    elif event.type == "raw_response_event":
                        if event.data.type == "response.output_text.delta":
                            # Handle text delta
                            item_id = event.data.item_id

                            # Check if we already have a streaming context for this item
                            if item_id not in item_id_to_streaming_context:
                                # Create a new streaming context for this item
                                streaming_context = adk.streaming.streaming_task_message_context(
                                    task_id=params.task_id,
                                    initial_content=TextContent(
                                        author="agent",
                                        content="",
                                    ),
                                )
                                # Open the streaming context
                                item_id_to_streaming_context[item_id] = await streaming_context.open()
                                unclosed_item_ids.add(item_id)
                            else:
                                streaming_context = item_id_to_streaming_context[item_id]

                            # Stream the delta through the streaming service
                            await streaming_context.stream_update(
                                update=StreamTaskMessageDelta(
                                    parent_task_message=streaming_context.task_message,
                                    delta=TextDelta(text_delta=event.data.delta),
                                ),
                            )

                        elif event.data.type == "response.output_item.done":
                            # Handle item completion
                            maybe_item_id = event.data.item.id

                            # Finish the streaming context (sends DONE event and updates message)
                            if maybe_item_id and maybe_item_id in item_id_to_streaming_context:
                                streaming_context = item_id_to_streaming_context[item_id]
                                await streaming_context.close()
                                unclosed_item_ids.remove(item_id)

                        elif event.data.type == "response.completed":
                            # All items complete, finish all remaining streaming contexts for this session
                            for item_id in unclosed_item_ids:
                                streaming_context = item_id_to_streaming_context[item_id]
                                await streaming_context.close()
                                unclosed_item_ids.remove(item_id)

            finally:
                # Cleanup: ensure all streaming contexts for this session are properly finished
                for item_id in unclosed_item_ids:
                    streaming_context = item_id_to_streaming_context[item_id]
                    await streaming_context.close()
                    unclosed_item_ids.remove(item_id)

            if span:
                span.output = {
                    "new_items": [
                        item.raw_item.model_dump() if isinstance(item.raw_item, BaseModel) else item.raw_item
                        for item in result.new_items
                    ],
                    "final_output": result.final_output,
                }

    return {"final_output": result.final_output, "final_input_list": result.to_input_list()}
