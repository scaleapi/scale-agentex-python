import json

from temporalio import workflow

from agentex.lib import adk
from agentex.lib.types.acp import CreateTaskParams, SendEventParams
from agentex.lib.core.temporal.workflows.workflow import BaseWorkflow
from agentex.lib.core.temporal.types.workflow import SignalName
from agentex.lib.utils.logging import make_logger
from agentex.types.text_content import TextContent
from agentex.lib.environment_variables import EnvironmentVariables

environment_variables = EnvironmentVariables.refresh()

if environment_variables.WORKFLOW_NAME is None:
    raise ValueError("Environment variable WORKFLOW_NAME is not set")

if environment_variables.AGENT_NAME is None:
    raise ValueError("Environment variable AGENT_NAME is not set")

logger = make_logger(__name__)

@workflow.defn(name=environment_variables.WORKFLOW_NAME)
class {{ workflow_class }}(BaseWorkflow):
    """
    Minimal async workflow template for AgentEx Temporal agents.
    """
    def __init__(self):
        super().__init__(display_name=environment_variables.AGENT_NAME)
        self._complete_task = False
        self._task_id = None
        self._trace_id = None
        self._parent_span_id = None

    @workflow.signal(name=SignalName.RECEIVE_EVENT)
    async def on_task_event_send(self, params: SendEventParams) -> None:
        logger.info(f"Received task message instruction: {params}")

        # Echo back the client's message to show it in the UI. This is not done by default
        # so the agent developer has full control over what is shown to the user.
        await adk.messages.create(task_id=params.task.id, content=params.event.content)

        # ============================================================================
        # NEXT STEPS: Using OpenAI Agents SDK with Temporal
        # ============================================================================
        # This project is configured with the OpenAI Agents SDK integration including:
        # - TemporalStreamingModelProvider for real-time token streaming
        # - ContextInterceptor for threading task_id through activities
        # - TemporalStreamingHooks (via stream_lifecycle_content activity)
        #
        # To use the OpenAI Agents SDK in your workflow:
        # 1. Add: from agents import Agent, Runner
        # 2. Add: from agentex.lib.core.temporal.plugins.openai_agents.hooks.hooks import TemporalStreamingHooks
        # 3. Initialize streaming context variables:
        #    self._task_id = params.task.id
        #    self._trace_id = params.task.id
        #    self._parent_span_id = params.task.id
        # 4. Create hooks: hooks = TemporalStreamingHooks(task_id=params.task.id)
        # 5. Create your agent and run: result = await Runner.run(agent, input, hooks=hooks)
        #
        # For complete examples with tools, see:
        # https://github.com/scaleapi/agentex-python/tree/main/examples/tutorials/10_agentic/10_temporal/070_open_ai_agents_sdk_tools
        # ============================================================================

        # Send a simple response message.
        # Replace this with your OpenAI Agents SDK logic following the pattern above.
        await adk.messages.create(
            task_id=params.task.id,
            content=TextContent(
                author="agent",
                content=f"Hello! I've received your message. See the comments above for how to integrate the OpenAI Agents SDK.",
            ),
        )

    @workflow.run
    async def on_task_create(self, params: CreateTaskParams) -> str:
        logger.info(f"Received task create params: {params}")

        # 1. Acknowledge that the task has been created.
        await adk.messages.create(
            task_id=params.task.id,
            content=TextContent(
                author="agent",
                content=f"Hello! I've received your task. Normally you can do some state initialization here, or just pass and do nothing until you get your first event. For now I'm just acknowledging that I've received a task with the following params:\n\n{json.dumps(params.params, indent=2)}.\n\nYou should only see this message once, when the task is created. All subsequent events will be handled by the `on_task_event_send` handler.",
            ),
        )

        await workflow.wait_condition(
            lambda: self._complete_task,
            timeout=None, # Set a timeout if you want to prevent the task from running indefinitely. Generally this is not needed. Temporal can run hundreds of millions of workflows in parallel and more. Only do this if you have a specific reason to do so.
        )
        return "Task completed"
